<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Text Adventure State Visualization</title>
    <style>
        main {
            width: 80em;
            margin: 0 auto;
            display: flex;
        }
        .control-form {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        #container {
            width: 70em;
            height: 95vh;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <main>
        <div id="container"></div>
        <div class="control-form">
            <div class="input-container">
                <label for="search">Node ID:</label>
                <input id="search" type="text">
            </div>
            <button id="search_button">Search</button>

            <div class="input-conatiner">
                <label for="path">Path:</label>
                <textarea id="path" name="" cols="30" rows="10"></textarea>
            </div>
            <button id="animate_button">Animate</button>
        </div>
    </main>

    <script src="static/sigma.js"></script>
    <script>
        (function() {
            var nodeColors = {
                'Dark Room': '#333',
                'Room with cage': '#3ff',
                'Hall Way': '#3f3',
                'Chamber': '#33f',
                'Dire Tombs': '#ff3',
                'Empty Room': '#f3f',
            };
            sigma.classes.graph.addMethod('orderEdges', function() {
                this.edgesArray.sort((a, b) => {
                    if(a.zIndex < b.zIndex)
                        return -1;
                    if(a.zIndex > b.zIndex)
                        return 1;
                    return 0;
                });
            });
            var nodeIDInput = document.getElementById('search');
            var pathInput = document.getElementById('path');
            // Let's first initialize sigma:
            var s = new sigma({
                renderers: [
                    {
                        container: document.getElementById('container'),
                        type: 'canvas' // sigma.renderers.canvas works as well
                    }
                ]
            });
            s.settings({
                minArrowSize: 5,
                minEdgeSize: 0,
                maxEdgeSize: 3,
                borderSize: 2,
            });
            s.bind('clickNode', function(e) {
                console.log(e)
                nodeIDInput.value = e.data.node.id;
                s.graph.edges().forEach(edge => {
                    if (edge.source === e.data.node.id) {
                        edge.color = '#f00';
                        edge.size = 5;
                        edge.zIndex = 1;
                    } else {
                        edge.color = '#eee';
                        edge.size = 0;
                        edge.zIndex = 0;
                    }
                });
                s.graph.orderEdges();
                s.refresh();
            });
            var counter = 0;
            fetch('/secret/states')
                .then(resp => {
                    return resp.json();
                })
                .then(states => {
                    states.forEach(state => {
                        nodeExists = s.graph.nodes()
                            .find(node => node.id === state.id);
                        if (!nodeExists) {
                            addNode(s.graph, state, nodeColors);
                        }
                        state.neighbors.forEach(n => {
                            counter ++;
                            nodes = s.graph.nodes();
                            neighborExists = nodes
                                .find(node => node.id === n.id);

                            if (!neighborExists) {
                                addNode(s.graph, n, nodeColors);
                            }
                            s.graph.addEdge({
                                id: 'e' + counter,
                                source: state.id,
                                target: n.id,
                                size: 0.5,
                                type: 'arrow',
                                color: '#ccc',
                                hover_color: '#000',
                            });
                        });
                    });
                    console.log(s.graph.nodes());
                    console.log(s.graph.edges());
                    s.refresh();
                });

            document.getElementById('search_button')
                .addEventListener('click', () => {
                    var nodeID = nodeIDInput.value;
                    s.graph.nodes().forEach(n => {
                        if (n.id == nodeID) {
                            s.dispatchEvent('clickNode', {node: n});
                        }
                    });
                });
            var animateTimeout, nodes, currentNode;
            document.getElementById('animate_button')
                .addEventListener('click', () => {
                    nodes = pathInput.value.split('\n');
                    console.log(nodes);
                    playAnimate(0);
                });

            function playAnimate(step) {
                animateTimeout = setTimeout(() => {
                    if (step < nodes.length) {
                        highlight(nodes[step], currentNode);
                        currentNode = nodes[step];
                        playAnimate(step+1);
                    }
                }, 1000);
            }
            function highlight(toNode, fromNode) {
                var highlightedNodes = [];
                s.graph.nodes()
                    .forEach(n => {
                        if (n.id === toNode || n.id === fromNode) {
                            n.color = '#f00';
                            highlightedNodes.push(n);
                        } else {
                            n.color = nodeColors[n.name];
                        }
                    });
                if (fromNode) {
                    s.graph.edges()
                        .forEach(e => {
                            if (e.source === fromNode && e.target === toNode) {
                                e.color = '#f00';
                                e.zIndex = 1;
                            } else {
                                e.color = '#eee';
                                e.zIndex = 0;
                            }
                        });
                }
                highlightedNodes.forEach(n => {
                    s.dispatchEvent('overNode', n);
                });
                s.graph.orderEdges();
                s.refresh();
            }

            function addNode (g, state, nodeColors) {
                g.addNode({
                    id: state.id,
                    name: state.location.name,
                    label: state.location.name + '-' + state.id,
                    x: state.location.x,
                    y: state.location.y,
                    size: 0.2 + Math.random(),
                    color: nodeColors[state.location.name],
                });
            }
        })()
    </script>
</body>
</html>
